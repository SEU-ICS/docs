{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ICS Lab Guidance","text":""},{"location":"#labs","title":"Labs","text":"<ul> <li>Shell Lab</li> <li>Malloc Lab</li> </ul>"},{"location":"malloc/","title":"Malloc Lab","text":"<p>Instructor: Prof. Zhen Ling</p>"},{"location":"malloc/#introduction","title":"Introduction","text":"<p>In this lab, you will be writing a dynamic storage allocator for C programs -- that is, your own version of the <code>malloc</code>, <code>free</code>, <code>realloc</code>, and <code>calloc</code> functions. You are encouraged to explore the design space creatively and implement an allocator that is correct, efficient, and fast.</p> <p>You are recommended to start by implementing an implicit list allocator. Subsequently, you can build on this foundation to implement other allocators (e.g., explicit list) to improve the performance of your heap allocator.</p>"},{"location":"malloc/#environment-setup","title":"Environment Setup","text":"<p>The code required for the malloc lab in hosted on the same GitHub repository in the shell lab. The following are the basic steps to setup your local experiment environment:</p> <ul> <li>Get the code:<ul> <li>downloading through the web page: Please refer to the shell lab guidance.</li> <li>using <code>git</code>: Execute <code>git pull</code> under the code directory if you downloaded the code using <code>git clone</code> in the previous shell lab. Otherwise, execute <code>git clone https://github.com/SEU-ICS/lab.git</code>.</li> </ul> </li> <li>Enter the lab directory: change your working directory to <code>lab/malloc</code> (or <code>lab-main/malloc</code>)</li> </ul>"},{"location":"malloc/#task-description","title":"Task Description","text":"<p>You will need to implement a dynamic storage allocator within <code>mm.c</code> by implementing the functions listed in Table-1. You may need to define other static helper functions used by the listed routines.</p> Table-1. Malloc Lab Functions to be Implemented Function Names Descriptions <code>int mm_init(void)</code> The exposed API that performs any necessary initializations, such as allocating the initial heap area. The return value should be -1 if there was a problem in performing the initialization, 0 otherwise. Note taht every time the driver executes a new trace, it resets your heap to the empty heap by calling your mm init function. <code>void *malloc(size_t size)</code> The exposed API that allocates memory chuncks. This routine returns a pointer to an allocated block payload of at least <code>size</code> bytes. The entire allocated block should lie within the heap region and should not overlap with any other allocated chunk. <code>void free(void *ptr)</code> The exposed API that frees allocated memory chunks. This routine frees the block pointed to by <code>ptr</code>. It returns nothing. This routine is only guaranteed to work when the passed pointer (i.e., <code>ptr</code>) was returned by an earlier call to <code>malloc</code>, <code>calloc</code>, or <code>realloc</code> and has not yet been freed. <code>free(NULL)</code> has no effect. <code>void *find_fit(size_t asize)</code> An internal function that locates a free memory chunk, used by <code>malloc()</code>. Find a block through all free blocks that meet the requirement of <code>asize</code>. <code>void place(void *bp, size_t asize)</code> An internal function that places the requested block in the new free block., used by <code>malloc()</code> <code>void *extend_heap(size_t words)</code> An internal function that extends the heap by <code>words</code> words. It returns a pointer to the new free block on success, <code>NULL</code> otherwise. <code>void *coalesce(void *bp)</code> An internal function that merges two adjacent free memory chunks and returns the merged block. We have handled the simple case where both the previous and the next chunks are allocated. You will need to implement other cases. <p>We have already implemented some helper routines in <code>memlib.c</code> which you can use:</p> <ul> <li><code>void *mem_sbrk(int incr)</code>: Expands the heap by <code>incr</code> bytes, where <code>incr</code> is a positive non-zero integer, and returns a generic pointer to the first byte of the newly allocated heap area. The semantics are identical to the Unix <code>sbrk</code> function, except that <code>mem_sbrk</code>accepts only a positive non-zero integer argument.</li> <li><code>void *mem_heap_lo(void)</code>: Returns a generic pointer to the first byte in the heap.</li> <li><code>void *mem_heap_hi(void)</code>: Returns a generic pointer to the last byte in the heap.</li> <li><code>size t mem_heapsize(void)</code>: Returns the current size of the heap in bytes.</li> <li><code>size t mem_pagesize(void)</code>: Returns the system\u2019s page size in bytes (4K on Linux systems).</li> </ul> <p>We have also provided the basic implementations of <code>calloc</code> and <code>realloc</code> in <code>mm.c</code>. However, you may need to modify these routines to improve the performance of your implementation.</p>"},{"location":"malloc/#checking-your-work","title":"Checking Your Work","text":""},{"location":"malloc/#the-trace-driven-driver-program","title":"The Trace-driven Driver Program","text":"<p>The driver program <code>mdriver</code> (compiled from <code>mdriver.c</code>) tests your <code>mm.c</code> implementation for correctness, space utilization, and throughput. The driver program is controlled by a set of trace files that are included in the <code>traces</code> folder. Each trace file contains a sequence of allocate and free operations that instruct the driver to call your <code>malloc</code> and <code>free</code> routines in some sequence. The driver and the trace files are the same ones we will use when we grade your handin <code>mm.c</code> file.</p> <p>When the driver program is run, it will run each trace file 12 times: once to make sure your implementation is correct, once to determine the space utilization, and 10 times to determine the performance.</p> <p>If you run <code>mdriver</code> with no command line arguments, it will test the correctness and performance of your <code>mm.c</code> implementation by default. It also accepts the following command line arguments, which you may find useful during the development.</p> <ul> <li> <p><code>-t &lt;tracedir&gt;</code>: Look for the default trace files in directory tracedir instead of the default directory defined in <code>config.h</code>.</p> </li> <li> <p><code>-f &lt;tracefile&gt;</code>: Use one particular tracefile instead of the default set of tracefiles for testing correctness and performance.</p> </li> <li> <p><code>-c &lt;tracefile&gt;</code>: Run a particular tracefile exactly once, testing only for correctness. This option is extremently useful if you want to print out debugging messages.</p> </li> <li> <p><code>-h</code>: Print a summary of the command line arguments.</p> </li> <li> <p><code>-l</code>: Run and measure libc malloc in addition to the student\u2019s malloc package. This is interesting mainly to see how slow the libc malloc package is.</p> </li> <li> <p><code>-V</code>: Verbose output. Print additional diagnostic information as each trace file is processed. Useful during debugging for determining which trace file is causing your malloc package to fail.</p> </li> <li> <p><code>-v &lt;verbose level&gt;</code>: This optional feature lets you manually set your verbose level to a particular integer.</p> </li> <li> <p><code>-d &lt;i&gt;</code>: At debug level <code>0</code>, very little validity checking is done. This is useful if you are mostly done but just tweaking performance. At debug level <code>1</code>, every array the driver allocates is filled with random bits. When the array is freed or reallocated, we check to make sure the bits have not been changed. This is the default. At debug level <code>2</code>, every time any operation is done, all arrays are checked. This is very slow but useful to discover problems very quickly.</p> </li> <li> <p><code>-D</code>: Equivalent to <code>-d2</code>.</p> </li> <li> <p><code>-s</code>: Time out after s seconds. The default is to never time out.</p> </li> <li> <p><code>-P</code>: Only output perf score to <code>stdout</code>.</p> </li> </ul> <p>Don't forget to execute <code>make -B</code> to compile your code. Some scripts listed below may re-compile your code with compiler flags that suppress debug outputs. Therefore it is recommended to execute <code>make -B</code> first before you want to play with <code>mdriver</code></p>"},{"location":"malloc/#correctness-check","title":"Correctness Check","text":"<p>To check the correctness of your heap implementation on all trace files, execute:</p> <pre><code>./scripts/exhaustive-heap-check.sh\n</code></pre> <p>To check the correctness of your heap implementation on only one trace files, execute:</p> <pre><code>./mdriver -c ./traces/&lt;name&gt;.rep\n# e.g., ./mdriver -c ./traces/binary.rep\n</code></pre>"},{"location":"malloc/#performance-check","title":"Performance Check","text":"<p>To check the performance of your heap implementation, execute:</p> <pre><code>./scripts/get-perf-index.sh\n</code></pre>"},{"location":"malloc/#debug-your-code","title":"Debug Your Code","text":"<p>Run <code>mdriver</code> with the <code>-D -v 2</code> option to get full debug output. If you want to check the working condition of your heap allocator on-the-fly, try to output some debug information in the <code>bool mm_checkheap(int lineno)</code> function within <code>mm.c</code>. The argument and return value of this function are useless and you can just safely ignore them. When <code>mdriver</code> is executed with the <code>-D</code> option, it calls <code>mm_checkheap</code> everytime before it performs heap operations (e.g., <code>malloc</code>, and <code>free</code>). For example, you can walk the whole heap and print every memory chunks to see how your heap changes over time.</p>"},{"location":"malloc/#programming-rules","title":"Programming Rules","text":"<ul> <li>You should not change any of the interfaces in <code>mm.h</code>. However, we strongly encourage you to use static helper functions in <code>mm.c</code> to break up your code into small, easy-to-understand segments.</li> <li>You should not invoke any external memory-management related library calls or system calls. The use of the libc <code>malloc</code>, <code>calloc</code>, <code>free</code>, <code>realloc</code>, <code>sbrk</code>, <code>brk</code>, or any other memory management packages is strictly prohibited.</li> <li>You are not allowed to define any global data structures such as arrays, structs, trees, or lists in your <code>mm.c</code> program. However, you are allowed to declare global scalar variables such as integers, floats, and pointers in <code>mm.c</code>.</li> </ul>"},{"location":"malloc/#grading","title":"Grading","text":"<p>The grading of the final hand-in will be based on the correctness and performance of your allocator on the given traces, the quality of your heap checker, and your coding style:</p> <ul> <li>Correctness (80 points): we use 20 trace files as test cases for correctness, each test case counts for 4 points, and you will get a total of 80 points if you pass all tests. Use the correctness check script mentioned above to estimate your correctness score.</li> <li>Performance (100 points): Two metrics will be used to evaluate your solution. Use the performance check script to estimate your performance score.<ul> <li>Space utilization: The peak ratio between the aggregate amount of memory used by the driver (i.e., allocated via <code>malloc</code> but not yet freed via <code>free</code>) and the size of the heap used by your allocator. The optimal ratio equals 1. You should find good policies to minimize fragmentation in order to make this ratio as close as possible to the optimal.</li> <li>Throughput: The average number of operations completed per second.</li> </ul> </li> </ul> <p>Your final grade is calculated by the following formula. The valuation of the weighting parameters \\(a\\) and \\(b\\) depends on the overall performance of the class.</p> \\[Grade = a \\times CorrectnessScore + b \\times PerformanceScore\\]"},{"location":"malloc/#hand-in-instructions","title":"Hand-In Instructions","text":"<p>We use GitHub Classroom to manage and organize labs. Follow these steps to submit your <code>mm.c</code>:</p> <ul> <li>Join the GitHub Classroom: You can safely jump to the next step if you have joined the classroom. Otherwise, an invitation link has been shared in the course group chat, open the link to join the GitHub Classroom. You'll need to register a GitHub account if you don't have one. You should be able to see your student ID (e.g., <code>09Jxxxxx</code>) listed in the roaster, please carefully find your student ID and link your GitHub account with it.</li> <li>Accept the assignment: An invitation link has been shared in the course group chat, you will need to open the link to accept the assignment. A private repository will be created for you once you accept the assignment.</li> <li>Submit your work: Submit your <code>mm.c</code> file to your repository with a commit. You can submit as many times as you want before the deadline. Please refer to the shell lab guidance for how to submit.</li> <li>Grading: Our auto-grading tool will automatically evaluate your submissions every time you push a commit. Only you, teachers and TAs can view the score of your submission. The score that auto-grader reports is the sum of your correctness score and performance score (i.e., \\(a=1, b=1\\)) and does not reflect your final grade. However, this score is guaranteed to positively correlates with your final grade -- higher score, higher final grade. We will use the score of your final submission to calculate your final grade for this lab.</li> </ul> <p>NOTE:</p> <ol> <li>You will not be able to submit your work after the deadline. Manage your time properly.</li> <li>The online auto-grader runs slow and should only be used to obtain your final score. Use the provided scripts locally to debug and evaluate your <code>mm.c</code>.</li> <li>Any modifications to the <code>.github</code> directory of your repository is STRICTLY PROHIBITED.</li> <li>Code plagiarism is STRICTLY PROHIBITED AND PUNISHED.</li> </ol> <p>Further instructions, if any, will be announced in form of class group notifications.</p>"},{"location":"shell/","title":"Shell Lab","text":"<p>Instructor: Prof. Zhen Ling</p>"},{"location":"shell/#introduction","title":"Introduction","text":"<p>The purpose of this lab is to become more familiar with the concepts of process control and signaling. You\u2019ll do this by writing a simple Unix shell program that supports job control.</p>"},{"location":"shell/#pre-requests","title":"Pre-requests","text":"<ul> <li>Please read through \"Chapter 8 Exception Control Flow\" from the textbook \"Computer Systems: A Programmer\u2019s Perspective (3rd Edition)\" and make sure you understand the literature and all sample codes.</li> <li>You will need a Linux distribution to finish this lab and the lab environment for your previous labs will do.</li> </ul>"},{"location":"shell/#environment-setup","title":"Environment Setup","text":"<p>The code required for this lab is hosted on a GitHub repository. The following are the basic steps to setup your local experiment environment:</p> <ul> <li>Get the code: You can download the code in two ways:<ul> <li>download through the web page: visit the GitHub repository, click the green button labeled <code>&lt;&gt;Code</code>, then click <code>Download ZIP</code> in the pop-up window to start downloading, and finally decompress the just downloaded <code>lab-main.zip</code> file.</li> <li>clone the repository using <code>git</code>: execute <code>git clone https://github.com/SEU-ICS/lab.git</code></li> </ul> </li> <li>Enter the lab directory: change your working directory to <code>lab/shell</code> (or <code>lab-main/shell</code>)</li> <li>Compile the code: execute <code>make</code> to compile and link some test routines.</li> </ul>"},{"location":"shell/#task-description","title":"Task Description","text":"<p>Your task is to implement a simple Unix Shell, tiny shell, within <code>tsh.c</code>. To help you get started, we have already implemented some less interesting functionalities, and the <code>tsh.c</code> file already contains a functional skeleton of tiny shell. However, there are still some missing parts (marked with <code>/* your code here */</code>) in the code. Your assignment is to complete the remaining empty functions listed in Table 1. Note that for our reference implementation, each function can be completed within 80 lines of code (LoC), some within 30 LoC.</p> **Table 1. Shell Lab Functions to be Implemented** Function Name Description <code>eval</code> Main routine that parses and interprets the command line <code>builtin_cmd</code> Recognizes and interprets the built-in commands: quit, fg, bg, and jobs <code>do_bgfg</code> Implements the bg and fg built-in commands <code>waitfg</code> Waits for a foreground job to complete <code>sigchld_handler</code> Catches SIGCHILD signals <code>sigint_handler</code> Catches SIGINT (ctrl-c) signals <code>sigtstp_handler</code> Catches SIGTSTP (ctrl-z) signals <p>Each time you modify your <code>tsh.c</code> file, don't forget to execute <code>make</code> to recompile it. To run your shell, type <code>./tsh</code> in the command line:</p> <pre><code>$ ./tsh\ntsh&gt; [type commands to your shell here]\n</code></pre> <p>At the very beginning, your shell skeleton can run but do nothing, shown as follows. You may find it hard to exit from the shell, e.g., you can not do so with <code>ctrl-c</code> because the signal (<code>SIGINT</code>) is ignored, and the <code>quit</code> command has not been implemented. However, you can use <code>ctrl-d</code> to trigger an end-of-file (<code>EOF</code>), or <code>ctrl-\\</code> to trigger a <code>SIGQUIT</code> signal to exit from the shell.</p> <pre><code>$ ./tsh\ntsh&gt; ls\ntsh&gt; quit\ntsh&gt; &amp;\ntsh&gt; ls | grep csapp\ntsh&gt; ^C^C^C\n</code></pre>"},{"location":"shell/#general-overview-of-unix-shells","title":"General Overview of Unix Shells","text":"<p>A shell is an interactive command-line interpreter that runs programs on behalf of the user. A shell repeatedly prints a prompt, waits for a command line on <code>stdin</code>, and then carries out some action, as directed by the contents of the command line.</p> <p>The command line is a sequence of ASCII text words delimited by whitespace. The first word in the command line is either the name of a built-in command or the pathname of an executable file. The remaining words are command-line arguments. If the first word is a built-in command, the shell immediately executes the command in the current process. Otherwise, the word is assumed to be the pathname of an executable program. In this case, the shell forks a child process, then loads and runs the program in the context of the child. The child processes created as a result of interpreting a single command line are known collectively as a job. In general, a job can consist of multiple child processes connected by Unix pipes.</p> <p>If the command line ends with an ampersand <code>&amp;</code>, then the job runs in the background, which means that the shell does not wait for the job to terminate before printing the prompt and awaiting the next command line. Otherwise, the job runs in the foreground, which means that the shell waits for the job to terminate before awaiting the next command line. Thus, at any point in time, at most one job can be running in the foreground. However, an arbitrary number of jobs can run in the background.</p> <p>For example, typing the command line</p> <pre><code>tsh&gt; jobs\ncauses the shell to execute the built-in jobs command. \nTyping the command line\ntsh&gt; /bin/ls -l -d \n</code></pre> <p>runs the <code>ls</code> program in the foreground. By convention, the shell ensures that when the program begins executing its main routine</p> <pre><code>int main(int argc, char *argv[])\n</code></pre> <p>the <code>argc</code> and <code>argv</code> arguments have the following values:</p> <pre><code>argc == 3\nargv[0] == \"/bin/ls\"\nargv[1]== -l\"\nargv[2]== \"-d\n</code></pre> <p>Alternatively, typing the command line</p> <pre><code>tsh&gt; /bin/ls -l -d &amp;\n</code></pre> <p>runs the <code>ls</code> program in the background. </p> <p>Unix shells support the notion of job control, which allows users to move jobs back and forth between background and foreground, and to change the process state (running, stopped, or terminated) of the processes in a job. Typing <code>ctrl-c</code> causes a <code>SIGINT</code> signal to be delivered to each process in the foreground job. The default action for <code>SIGINT</code> is to terminate the process. Similarly, typing <code>ctrl-z</code> causes a <code>SIGTSTP</code> signal to be delivered to each process in the foreground job. The default action for <code>SIGTSTP</code> is to place a process in the stopped state, where it remains until it is awakened by the receipt of a <code>SIGCONT</code> signal. Unix shells also provide various built-in commands that support job control. For example:</p> <ul> <li><code>jobs</code>: List the running and stopped background jobs. </li> <li><code>bg &lt;job&gt;</code>: Change a stopped background job to a running background job. </li> <li><code>fg &lt;job&gt;</code>: Change a stopped or running background job to a running in the foreground. </li> <li><code>kill &lt;job&gt;</code>: Terminate a job.</li> </ul>"},{"location":"shell/#the-tsh-specification","title":"The <code>tsh</code> Specification","text":"<p>Your <code>tsh</code> shell should have the following features:</p> <ul> <li>The prompt should be the string <code>tsh&gt;</code>.</li> <li>The command line typed by the user should consist of a <code>&lt;name&gt;</code> and zero or more arguments, all separated by one or more spaces. If <code>&lt;name&gt;</code> is a built-in command, then <code>tsh</code> should handle it immediately and wait for the next command line. Otherwise, <code>tsh</code> should assume that <code>&lt;name&gt;</code> is the path of an executable file, which it loads and runs in the context of an initial child process (In this context, the term job refers to this initial child process).</li> <li><code>tsh</code> does not need to support pipes (|) or I/O redirection (&lt; and &gt;). </li> <li>Typing <code>ctrl-c</code> (<code>ctrl-z</code>) should cause a <code>SIGINT</code> (<code>SIGTSTP</code>) signal to be sent to the current foreground job, as well as any descendants of that job (e.g., any child processes that it forked). If there is no foreground job, then the signal should have no effect. </li> <li>If the command line ends with an ampersand <code>&amp;</code>, then <code>tsh</code> should run the job in the background. Otherwise, it should run the job in the foreground. </li> <li>Each job can be identified by either a process ID (PID) or a job ID (JID), which is a positive integer assigned by <code>tsh</code>. PID and JID are two distinct IDs for a certain job. The PID is determined by the operating system while the JID is assigned by <code>tsh</code>. For example, a job can have a PID of 9978 while having a JID of 8 at the same time and this job can be equally identified using either PID 9978 or JID 8. JIDs should be denoted on the command line by the prefix <code>%</code>. For example, <code>%5</code> denotes JID 5, and <code>5</code> denotes PID 5. (We have provided you with all of the routines you need for manipulating the job list so that you do not need to implement them yourselves.) </li> <li><code>tsh</code> should support the following built-in commands: <ul> <li>The <code>quit</code> command terminates the shell. </li> <li>The <code>jobs</code> command lists all background jobs. </li> <li>The <code>bg &lt;job&gt;</code> command restarts <code>&lt;job&gt;</code> by sending it a <code>SIGCONT</code> signal, and then runs it in the background. The <code>&lt;job&gt;</code> argument can be either a PID or a JID. </li> <li>The <code>fg &lt;job&gt;</code> command restarts <code>&lt;job&gt;</code> by sending it a <code>SIGCONT</code> signal, and then runs it in the foreground. The <code>&lt;job&gt;</code> argument can be either a PID or a JID. </li> </ul> </li> <li><code>tsh</code> should reap all of its zombie children. If any job terminates because it receives a signal, then <code>tsh</code> should recognize this event and print a message with the job\u2019s PID and a description of the signal.</li> </ul>"},{"location":"shell/#checking-your-work","title":"Checking Your Work","text":"<p>We have provided some tools to help you check your work. </p>"},{"location":"shell/#reference-solution","title":"Reference Solution","text":"<p>The Linux executable <code>tshref</code> is the reference solution for the shell. You are encouraged to first paly with this shell by typing</p> <pre><code>$ ./tshref\ntsh&gt; /bin/ls\n</code></pre> <p>to call <code>ls</code> from the reference shell and you should get outputs similar to those by running <code>ls</code> through a Linux shell. Run this program to resolve any questions you have about how your shell should behave. Your shell should emit output that is identical to the reference solution (except for PIDs, of course, which change from run to run).</p>"},{"location":"shell/#shell-driver","title":"Shell Driver","text":"<p>The <code>sdriver.pl</code> program executes a shell as a child process, sends it commands and signals as directed by a trace file, and captures and displays the output from the shell. </p> <pre><code>$ ./sdriver.pl -h\n\nUsage: ./sdriver.pl [-hv] -t &lt;trace&gt; -s &lt;shellprog&gt; -a &lt;args&gt;\nOptions:\n  -h            Print this message\n  -v            Be more verbose\n  -t &lt;trace&gt;    Trace file\n  -s &lt;shell&gt;    Shell program to test\n  -a &lt;args&gt;     Shell arguments\n  -g            Generate output for autograder\n</code></pre>"},{"location":"shell/#trace-files","title":"Trace Files","text":"<p>We have also provided 16 trace files (<code>trace{01-16}.txt</code>) that you will use in conjunction with the shell driver to test the correctness of your shell. The lower-numbered trace files do very simple tests, and the higher-numbered tests do more complicated tests.</p> <p>You can run the shell driver on your shell using trace file (<code>trace01.txt</code> for instance) by typing:</p> <pre><code>$ ./sdriver.pl -t trace01.txt -s ./tsh -a \"-p\"\n</code></pre> <p>(the -a \"-p\" argument tells your shell not to emit a prompt), or</p> <pre><code>$ make test01\n</code></pre> <p>Similarly, to run the shell driver on the reference shell, execute: by typing:</p> <pre><code>$ ./sdriver.pl -t trace01.txt -s ./tshref -a \"-p\"\n</code></pre> <p>or</p> <pre><code>$ make rtest01\n</code></pre> <p>You can compare the outputs of both shells to know if you have done things right.</p> <p>To run all trace files with the reference shell, execute:</p> <pre><code>$ ./reftest.sh\n</code></pre> <p>This command will generate output of all test cases. For your reference, <code>tshref.out</code> gives the output of the reference solution on all traces. This might be more convenient for you than manually running the shell driver on all trace files.</p> <p>The neat thing about the trace files is that they generate the same output you would have gotten had you run your shell interactively (except for an initial comment that identifies the trace). For example:</p> <pre><code>$ make rtest15\n./sdriver.pl -t trace15.txt -s ./tshref -a \"-p\"\n#\n# trace15.txt - Putting it all together\n#\ntsh&gt; ./bogus\n./bogus: Command not found\ntsh&gt; ./myspin 10\nJob [1] (11472) terminated by signal 2\ntsh&gt; ./myspin 3 &amp;\n[1] (11491) ./myspin 3 &amp;\ntsh&gt; ./myspin 4 &amp;\n[2] (11493) ./myspin 4 &amp;\ntsh&gt; jobs\n[1] (11491) Running ./myspin 3 &amp;\n[2] (11493) Running ./myspin 4 &amp;\ntsh&gt; fg %1\nJob [1] (11491) stopped by signal 20\ntsh&gt; jobs\n[1] (11491) Stopped ./myspin 3 &amp;\n[2] (11493) Running ./myspin 4 &amp;\ntsh&gt; bg %3\n%3: No such job\ntsh&gt; bg %1\n[1] (11491) ./myspin 3 &amp;\ntsh&gt; jobs\n[1] (11491) Running ./myspin 3 &amp;\n[2] (11493) Running ./myspin 4 &amp;\ntsh&gt; fg %1\ntsh&gt; quit\n</code></pre>"},{"location":"shell/#hints","title":"Hints","text":"<ul> <li>Use the trace files to guide the development of your shell. Starting with <code>trace01.txt</code>, make sure that your shell produces the identical output as the reference shell. Then move on to trace file <code>trace02.txt</code>, and so on.</li> <li>The <code>waitpid</code>, <code>kill</code>, <code>fork</code>, <code>execve</code>, <code>setpgid</code>, and <code>sigprocmask</code> functions will come in very handy. The <code>WUNTRACED</code> and <code>WNOHANG</code> options to <code>waitpid</code> will also be useful.</li> <li>When you implement your signal handlers, be sure to send <code>SIGINT</code> and <code>SIGTSTP</code> signals to the entire foreground process group, using <code>-pid</code> instead of <code>pid</code> in the argument to the <code>kill</code> function. The <code>sdriver.pl</code> program tests for this error.</li> <li>One of the tricky parts of the assignment is deciding on the allocation of work between the <code>waitfg</code> and <code>sigchld_handler</code> functions. We recommend the following approach:<ul> <li>In <code>waitfg</code>, use a busy loop around the sleep function.</li> <li>In <code>sigchld_handler</code>, use exactly one call to <code>waitpid</code>. While other solutions are possible, such as calling <code>waitpid</code> in both <code>waitfg</code> and <code>sigchld_handler</code>, these can be very confusing. It is simpler to do all reaping in the handler.</li> </ul> </li> <li>In <code>eval</code>, the parent must use <code>sigprocmask</code> to block <code>SIGCHLD</code> signals before it forks the child, and then unblock these signals, again using sigprocmask after it adds the child to the job list by calling <code>addjob</code>. Since children inherit the blocked vectors of their parents, the child must be sure to then unblock <code>SIGCHLD</code> signals before it execs the new program. The parent needs to block the <code>SIGCHLD</code> signals in this way in order to avoid the race condition where the child is reaped by <code>sigchld_handler</code> (and thus removed from the job list) before the parent calls <code>addjob</code>.</li> <li>Programs such as <code>more</code>, <code>less</code>, <code>vi</code>, and <code>emacs</code> do strange things with the terminal settings. Don\u2019t run these programs from your shell. Stick with simple text-based programs such as <code>/bin/ls</code>, <code>/bin/ps</code>, and <code>/bin/echo</code>.</li> <li>When you run your shell from the standard Unix shell, your shell is running in the foreground process group. If your shell then creates a child process, by default that child will also be a member of the foreground process group. Since typing <code>ctrl-c</code> sends a <code>SIGINT</code> to every process in the foreground group, typing <code>ctrl-c</code> will send a <code>SIGINT</code> to your shell, as well as to every process that your shell created, which obviously isn\u2019t correct. Here is the workaround: After the <code>fork</code>, but before the <code>execve</code>, the child process should call <code>setpgid(0, 0)</code>, which puts the child in a new process group whose group ID is identical to the child\u2019s PID. This ensures that there will be only one process, your shell, in the foreground process group. When you type <code>ctrl-c</code>, the shell should catch the resulting <code>SIGINT</code> and then forward it to the appropriate foreground job (or more precisely, the process group that contains the foreground job).</li> </ul>"},{"location":"shell/#grading","title":"Grading","text":"<p>We use the aforementioned 16 trace files as test cases, each test case counts for 5 points, and you will get a total of 80 points if you pass all tests. We provide you an auto-grading script <code>test.py</code>. The script will execute the shell driver with the shell program set to <code>./tsh</code>, and compare the outputs with that of the reference shell (i.e., <code>./tshref.out</code>). The script shows the following outputs for a \"correct\" tiny shell implementation:</p> <pre><code>$ python test.py \ntest case 01 passed\ntest case 02 passed\ntest case 03 passed\ntest case 04 passed\ntest case 05 passed\ntest case 06 passed\ntest case 07 passed\ntest case 08 passed\ntest case 09 passed\ntest case 10 passed\ntest case 11 passed\ntest case 12 passed\ntest case 13 passed\ntest case 14 passed\ntest case 15 passed\ntest case 16 passed\n</code></pre> <p>If you don\u2019t see something like <code>test case &lt;idx&gt; passed</code> in the outputs, your <code>tsh</code> implementation does not pass the corresponding test case. Under this case, you can compare your output with the reference output, fix your code accordingly, recompile it, and execute <code>python test.py --case &lt;idx&gt;</code> later to see if you have passed that specific test case. See the help message (<code>python test.py --help</code>) for more details.</p> <p>Your solution shell will be tested for correctness on a Linux machine, using the same shell driver and trace files that were included in your lab directory. Your shell should produce identical output on these traces as the reference shell, with only two exceptions:</p> <ul> <li>The PIDs can (and will) be different. </li> <li>The output of the <code>/bin/ps</code> commands in <code>trace11.txt</code>, <code>trace12.txt</code>, and <code>trace13.txt</code> will be different from run to run. However, the running states of any mysplit processes in the output of the <code>/bin/ps</code> command should be identical.</li> </ul>"},{"location":"shell/#hand-in-instructions","title":"Hand-In Instructions","text":"<p>We use GitHub Classroom to manage and organize labs. Follow these steps to submit your <code>tsh</code> implementation:</p> <ul> <li>Join the GitHub Classroom: An invitation link has been shared in the course group chat, open the link to join the GitHub Classroom. You'll need to register a GitHub account if you don't have one. You should be able to see your student ID (e.g., <code>09Jxxxxx</code>) listed in the roaster, please carefully find your student ID and link your GitHub account with it.</li> <li>Accept the assignment: After joining the Classroom, there will be a window asking you to accept the assignment. A private repository will be created for you once you accept the assignment.</li> <li>Submit your work: Submit your <code>tsh.c</code> file to your repository with a commit. You can submit as many times as you want before the deadline. There are two ways to submit your work:<ul> <li>operate on the web page: open your repository, click <code>tsh.c</code>, click the pencil icon in the upper right corner, copy-paste the content your local <code>tsh.c</code> file to the web page, click the green button labeled <code>Commit changes...</code>, and click the green button labeled with <code>Commit changes</code> in the pop-up window.</li> <li>use <code>git</code>: clone the repository with <code>git clone https://github.com/SEU-ICS/shell-lab-&lt;your id here&gt;.git</code>, copy your local <code>tsh.c</code> file to <code>shell-lab-&lt;your id here&gt;/tsh.c</code>, then commit the changes with <code>git add . &amp;&amp; git commit &amp;&amp; git push</code>.</li> </ul> </li> <li>Grading: Our auto-grading tool will automatically evaluate your submissions every time you push a commit. Only you, teachers and TAs can view the score of your submission. The score of your final submission will serve as your grade for this lab.</li> </ul> <p>NOTE:</p> <ol> <li>You will not be able to submit your work after the deadline. Manage your time properly.</li> <li>The online auto-grader runs slow and should only be used to obtain your final score. Use the provided scripts locally to debug and evaluate your <code>tsh</code>.</li> <li>DO NOT modify ANYTHING under the <code>.github</code> directory of your repository. A script will examine your repositories for such behaviors after the deadline, and we will regrade your submission if you violate this rule.</li> </ol> <p>Further instructions, if any, will be announced in form of class group notifications.</p>"}]}